<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="/node-pile/pile/min/global.css?v=8debe17607d36dbbb958d3815f3aa90289a06ce2">
    <script type="text/javascript" src="/node-pile/pile/min/global.js?v=e431f0ce0f3f0df75f2ac670892a93ef64d321c6"></script>
</head>
  <body>
    <div id="container">
      <ul>
        <li>
          <a href="#">eka</a>
        </li>
        <li>
          <a href="#">toka</a>
        </li>
      </ul>
      <div class="readme">
        <h1>
          <span class="anchor" id="awesome-asset-manager-for-nodejs-and-express-node-pile"> -  </span>
Awesome asset manager for Node.js and Express: node-pile          <a class="anchor" href="#awesome-asset-manager-for-nodejs-and-express-node-pile">¶</a>
        </h1>
        <p>
          <em>node-pile</em>
 allows you to manage all your JavaScript and CSS assets cleanly
directly from code. It will concatenate and minify them in production and it
takes care of rendering the tags as every other proper asset manager.</p>
        <p>So why create a yet another asset manager? Because Node.js is special. In
Node.js a JavaScript asset isn't just a pile of bits that are sent to the
browser. It's code. It's code that can be also used in the server and I think
that it's the job of asset managers to help with it. So in           <em>node-pile</em>
 you can
take code directly from your Javascript objects, not just from JavaScript
files. Copying things from Rails is just not enought.</p>
        <p>Server-side code:</p>
        <pre>
          <code>js.addOb({BROWSER_GLOBAL: {
    aFunction: function() {
        console.log("Hello I'm in the browser also. Here I have", window, "and other friends");
    }
}});
</code>
        </pre>
        <p>You can also tell           <em>node-pile</em>
 to directly execute some function in the browser:</p>
        <pre>
          <code>js.addExec(function() {
    BROWSER_GLOBAL.aFunction();
    alert("Hello" + window.navigator.appVersion);
});
</code>
        </pre>
        <p>Currently           <em>node-pile</em>
 works only with           <a href="http://expressjs.com/">Express</a>
, but other frameworks
are planned as well.</p>
        <p>
          <em>node-pile</em>
 is written following principles in mind:</p>
        <ul>          <li>Creating best possible production setup for assets should be as easy as
including script/link to a page.</li>
          <li>Namespaces. You don't want to serve huge blob of admin view code for all
anonymous users.</li>
          <li>Support any JS- or CSS-files. No need to create special structure for your
assets. Just include your jQueries or whatever.</li>
          <li>Preprocessor languages are first class citizens. Eg. Just change the file
extension to .coffee to use CoffeeScript. That's it. No need to worry about
compiled files.</li>
          <li>Use heavy caching. Browser caches are killed automatically using the hash
sum of the assets.</li>
          <li>Awesome development mode. Build-in support for live CSS reloading.</li>
</ul>
        <p>Full example</p>
        <pre>
          <code>var createServer = require("express").createServer;
var pile = require("pile");

var app = createServer();
var js = pile.createJSManager();
var css = pile.createCSSManager();



app.configure(function() {
    js.bind(app);
    css.bind(app);

    css.addFile(__dirname + "/style.css");

    js.addUrl("http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js");
    js.addFile(__dirname + "/client/hello.js");
});


app.configure("development", function() {
    js.liveUpdate(css);
});

js.addOb({ VERSION: "1.0.0" });

js.exec(function() {
    alert("Hello browser" + window.navigator.appVersion);
});

app.get("/", function(req, res){
    res.render("index.jade", { layout: false });
});

app.listen(8080);
</code>
        </pre>
        <p>index.jade:</p>
        <pre>
          <code>!!! 5
html
  head
    !{renderStyleTags()}
    !{renderScriptTags()}
  body
    h1 Hello node-pile!
    #container !{body}
</code>
        </pre>
        <h2>
          <span class="anchor" id="namespaces"> -  </span>
Namespaces          <a class="anchor" href="#namespaces">¶</a>
        </h2>
        <p>The example above uses just a one pile. The global pile.</p>
        <p>If you for example want to add big editor files only for administration pages
you can create a pile for it:</p>
        <pre>
          <code>js.addFile("admin", __dirname + "/editor.js");
js.addFile("admin", __dirname + "/editor.extension.js");
</code>
        </pre>
        <p>This will add file editor.js and editor.extension.js to a admin pile. Now you
can add that to your admin pages by using giving it as parameter for
          <em>renderScriptTags</em>
.</p>
        <pre>
          <code>!{renderScriptTags("admin")}
</code>
        </pre>
        <p>This will render script-tags for the global pile and the admin-pile.
          <em>renderScriptTags</em>
 and           <em>renderStyleTags</em>
 can take variable amount of arguments.
Use           <em>renderScriptTags("pile1", "pile2", ....)</em>
 to render multiple namespaces</p>
        <p>Piling works just the same with css.</p>
        <h2>
          <span class="anchor" id="sharing-code-with-the-server"> -  </span>
Sharing code with the server          <a class="anchor" href="#sharing-code-with-the-server">¶</a>
        </h2>
        <p>Ok, that's pretty much what every asset manager does, but with           <em>node-pile</em>
 you
can share code directly from your server code.</p>
        <p>Let's say that you want to share a email-validating function with a server and
the client</p>
        <pre>
          <code>function isEmail(s) {
  return !! s.match(/.\w+@\w+\.\w/);
}
</code>
        </pre>
        <p>You can share it with           <em>addOb</em>
 -method:</p>
        <pre>
          <code>js.addOb({MY: {
   isEmail: isEmail
   }
});
</code>
        </pre>
        <p>Now on the client you can find the isEmail-function from MY.isEmail.</p>
        <p>
          <em>addOb</em>
 takes an object which will be merged to global window-object on the
client. So be carefull when choosing the keys. The object can be almost any
JavaScript object. It will be serialized and sent to the browser. Few caveats:</p>
        <ol>          <li>No circural references</li>
          <li>Functions will be serialized using Function.prototype.toString. So closures
 won't transferred to the client!</li>
</ol>
        <h3>
          <span class="anchor" id="pattern-for-sharing-full-modules"> -  </span>
Pattern for sharing full modules          <a class="anchor" href="#pattern-for-sharing-full-modules">¶</a>
        </h3>
        <p>This is nothing specific to           <em>node-pile</em>
, but this is a nice pattern which can
be used to share modules between the server and the client.</p>
        <p>share.js</p>
        <pre>
          <code>(function(exports){

  exports.test = function(){
       return 'This is a function from shared module';
  };

}(typeof exports === 'undefined' ? this.share = {} : exports));
</code>
        </pre>
        <p>In Node.js you can use it by just requiring it as any other module</p>
        <pre>
          <code>var share = require("./share.js");
</code>
        </pre>
        <p>and you can share it the client using           <em>addFile</em>
:</p>
        <pre>
          <code>js.addFile(__dirname + "./share.js");
</code>
        </pre>
        <p>Now you can use it in both as you would expect</p>
        <pre>
          <code>share.test();
</code>
        </pre>
        <p>You can read more about the pattern from           <a href="http://caolanmcmahon.com/posts/writing_for_node_and_the_browser">here</a>
        </p>
        <h2>
          <span class="anchor" id="awesome-development-mode"> -  </span>
Awesome development mode!          <a class="anchor" href="#awesome-development-mode">¶</a>
        </h2>
        <p>Development and production modes works as in Express. By default the
development mode is active. To activate production mode set NODE_ENV
environment variable to           <em>production</em>
.</p>
        <h3>
          <span class="anchor" id="script-tag-rendering"> -  </span>
Script-tag rendering          <a class="anchor" href="#script-tag-rendering">¶</a>
        </h3>
        <p>In development mode every js- and css-file will be rendered as a separate tag.</p>
        <p>For example renderScriptTags("admin") will render</p>
        <pre>
          <code>js.addFile(__dirname + "/helpers.js");
js.addFile("admin", __dirname + "/editor.js");
js.addFile("admin", __dirname + "/editor.extension.js");
</code>
        </pre>
        <p>to</p>
        <pre>
          <code>&lt;script type="text/javascript" src="/pile/js/dev/_global/1710d-helpers.js?v=1317298508710" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/pile/js/dev/admin/3718d-editor.js?v=1317298508714" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/pile/js/dev/admin/1411d-editor.extension.js?v=1317298508716" &gt;&lt;/script&gt;
</code>
        </pre>
        <p>in development mode, but in production it will render to</p>
        <pre>
          <code>&lt;script type="text/javascript"  src="/pile/js/min/_global.js?v=f1d27a8d9b92447439f6ebd5ef8f7ea9d25bc41c"  &gt;&lt;/script&gt;
&lt;script type="text/javascript"  src="/pile/js/min/admin.js?v=2d730ac54f9e63e1a7e99cd669861bda33905365"  &gt;&lt;/script&gt;
</code>
        </pre>
        <p>So debugging should be as easy as directly using script-tags.</p>
        <h3>
          <span class="anchor" id="live-css-editing"> -  </span>
Live CSS editing          <a class="anchor" href="#live-css-editing">¶</a>
        </h3>
        <p>Because           <em>node-pile</em>
 handles the script-tag rendering it is possible to add
some development tools when in development mode.</p>
        <p>Using Express you can automatically add Live CSS editing:</p>
        <pre>
          <code>app.configure("development", function() {
   js.liveUpdate(css);
});
</code>
        </pre>
        <p>This is similar to           <a href="http://livejs.com/">Live.js</a>
, but it does not use polling. It will add
socket.io add will push the CSS-updates to your browser as you edit them.</p>
        <p>If you app already uses Socket.io you need to add the io-object as second
parameter to liveUpdate:</p>
        <pre>
          <code>var io = require('socket.io').listen(app);
js.liveUpdate(css, io);
</code>
        </pre>
        <h2>
          <span class="anchor" id="examples"> -  </span>
Examples          <a class="anchor" href="#examples">¶</a>
        </h2>
        <p>https://github.com/epeli/node-pile/blob/master/examples/simple/app.js</p>
        <h2>
          <span class="anchor" id="api-summary"> -  </span>
API summary          <a class="anchor" href="#api-summary">¶</a>
        </h2>
        <p>Code will be rendered in the order you call these functions with the exception
of           <em>addUrl</em>
 which will be rendered before any other.</p>
        <h3>
          <span class="anchor" id="javascript-pile"> -  </span>
JavaScript pile          <a class="anchor" href="#javascript-pile">¶</a>
        </h3>
        <h4>addFile( [namespace], path to a asset file)</h4>
        <h4>addUrl( [namespace], url to a asset file)</h4>
        <p>Useful for CDNs and for dynamic assets in other libraries such as socket.io.</p>
        <h4>addOb( [namespace], any Javascript object )</h4>
        <p>Keys of the object will be added as globals. So take care when choosing those.
Also remember that parent scope of functions will be lost.</p>
        <h4>addExec( [namespace], Javascript function )</h4>
        <p>A function that will executed immediately in browser as it is parsed. Parent
scope is also lost here.</p>
        <h4>addRaw( [namespace], raw Javascript string )</h4>
        <h3>
          <span class="anchor" id="css-pile"> -  </span>
CSS pile          <a class="anchor" href="#css-pile">¶</a>
        </h3>
        <p>These are similar to ones in JS pile.</p>
        <h4>addFile( [namespace], path to a asset file)</h4>
        <h4>addUrl( [namespace], url to a asset file)</h4>
        <h4>addRaw( [namespace], raw CSS string )</h4>
        <h3>
          <span class="anchor" id="response-object"> -  </span>
Response object          <a class="anchor" href="#response-object">¶</a>
        </h3>
        <p>
          <em>node-pile</em>
 also adds few extra methods to your response objects.</p>
        <h4>res.exec( Javascript function )</h4>
        <p>Execute this function only on this response.</p>
        <h4>res.share( any Javascript object )</h4>
        <p>Similar to js.addOb, but only for this response.</p>
        <p>THIS ONE IS NOT IMPLEMENTED YET</p>
        <h2>
          <span class="anchor" id="supported-preprocessors"> -  </span>
Supported preprocessors          <a class="anchor" href="#supported-preprocessors">¶</a>
        </h2>
        <p>For JavaScript the only supported one is           <a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a>
 and the compiler is
included in           <em>node-pile</em>
.</p>
        <p>CSS-compilers are not included in           <em>node-pile</em>
. Just install what you need using
          <a href="http://npmjs.org/">npm</a>
.</p>
        <ul>          <li>
            <a href="http://learnboost.github.com/stylus/">Stylus</a>
 with             <a href="https://github.com/visionmedia/nib">nib</a>
 (npm install stylus nib)</li>
          <li>
            <a href="http://lesscss.org/">LESS</a>
 (npm install less)</li>
</ul>
        <p>Adding support for new compilers should be
          <a href="https://github.com/epeli/node-pile/blob/master/lib/compilers.coffee">easy</a>
.</p>
        <p>Feel free to contribute!</p>
        <h2>
          <span class="anchor" id="installing"> -  </span>
Installing          <a class="anchor" href="#installing">¶</a>
        </h2>
        <p>From           <a href="http://npmjs.org/">npm</a>
        </p>
        <pre>
          <code>npm install pile
</code>
        </pre>
        <h2>
          <span class="anchor" id="contact"> -  </span>
Contact          <a class="anchor" href="#contact">¶</a>
        </h2>
        <p>Questions and suggestions are very welcome</p>
        <ul>          <li>
            <a href="http://esa-matti.suuronen.org/">Esa-Matti Suuronen</a>
          </li>
          <li>esa-matti [aet] suuronen dot org</li>
          <li>
            <a href="https://twitter.com/#!/EsaMatti">EsaMatti</a>
 @ Twitter</li>
          <li>Epeli @ freenode/IRCnet</li>
</ul>
      </div>
    </div>
  </body>
</html>
